<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Ready-Set-Go Task</title>
  <script src="https://unpkg.com/jspsych@7.3.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.1"></script>
  <script src="https://cdn.plot.ly/plotly-2.20.0.min.js"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-text@1.1.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.1"></script>
  <link href="https://unpkg.com/jspsych@7.3.0/css/jspsych.css" rel="stylesheet" />
  <style>
    .circle-left {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background-color: red;
  position: absolute;
  left: 10%;    /* Adjust for desired horizontal position */
  top: 100px;   /* Adjust for vertical position */
}

.circle-right {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background-color: red;
  position: absolute;
  right: 10%;   /* Adjust for desired horizontal position */
  top: 100px;   /* Adjust for vertical position */
}
    .circle {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      margin: 100px auto;
      background-color: red;
    }
    .ready {
      background-color: blue;
    }
    .set {
      background-color: green;
    }
    #plot {
      width: 600px;
      height: 400px;
      margin: 30px auto;
    }
  </style>
</head>
<body></body>

<script>
  const num_trials = 300;
  const feedbackTrialsCount = 300;
  const jsPsych = initJsPsych();
  const lower_bound = 200;
  const upper_bound = 1500;

  const timeline = [];
  let subject_id = '';

  timeline.push({
    type: jsPsychSurveyText,
    questions: [{ prompt: "Please enter your subject ID or name:", name: "subject_id" }],
    button_label: "Start",
    on_finish: function(data) {
      const subject_id = data.response.Q0;
      jsPsych.data.addProperties({ "subject_ID": subject_id});
    }
  });

  // Instructions
  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <p>Ready-Set-Go Task:</p>
      <ul style="text-align:left; max-width:600px; margin:auto;">
        <li><strong>Blue circle ("Ready")</strong> appears</li>
        <li>Then, after a delay, a <strong>green circle ("Set")</strong> appears</li>
        <li>After "Set" disappears, screen goes blank</li>
        <li>You must <strong>press SPACE</strong> when you think the same delay has passed</li>
        <li>After you press, a red circle will appear</li>
        <li>Then you'll see how close your timing was (only for the first 5 trials).</li>
      </ul>
      <p>Press any key to begin.</p>
    `,
  });

  
  function make_ready_set_go_trial(trialIndex) {
  // Randomly assign trial type: left (A key) or right (K key)
const trialType = jsPsych.randomization.sampleWithoutReplacement(['left', 'right'], 1)[0];
const response_key = trialType === 'left' ? 'a' : 'k';
const ready_color = trialType === 'left' ? 'blue' : 'orange';
const ready_letter = trialType === 'left' ? 'A' : 'K';

// Define bounds for each type
const bounds_left = { lower: 200, upper: 400 };
const bounds_right = { lower: 1000, upper: 1200 };

// Decide if this trial is a "swap" trial (20% chance)
const swap_distribution = Math.random() < 0.2;  // true on 20% of trials

// Pick bounds based on trial type + swap
let interval_bounds;
if (trialType === 'left') {
  interval_bounds = swap_distribution ? bounds_right : bounds_left;
} else {
  interval_bounds = swap_distribution ? bounds_left : bounds_right;
}

// Create discrete steps
const n = 5;
const intervalSteps = Array.from({ length: n }, (_, i) =>
  Math.round(interval_bounds.lower + i * (interval_bounds.upper - interval_bounds.lower) / (n - 1))
);

// Pick a random interval from the chosen steps
const interval_ms = jsPsych.randomization.sampleWithoutReplacement(intervalSteps, 1)[0];

  const set_lower_bound = 200;
  const set_upper_bound = 200;
  const N = 3;
  const setSteps = Array.from({ length: N }, (_, i) =>
    Math.round(set_lower_bound + i * (set_upper_bound - set_lower_bound) / (N - 1))
  );
  const setDuration = jsPsych.randomization.sampleWithoutReplacement(setSteps, 1)[0];


  const trialTimeline = [
    {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<div class="circle" 
    style="
      background-color:${ready_color};
      color:white;
      font-size:48px;
      line-height:100px;
      text-align:center;
      position:absolute;
      ${trialType === 'left' ? 'left:30%;' : 'right:30%;'}
      top:160px;
    ">
    ${ready_letter}
  </div>`,

      // stimulus: `<div class="circle" style="background-color:${ready_color}; color:white; font-size:48px; line-height:100px; text-align:center;">${ready_letter}</div>`,
      choices: "NO_KEYS",
      trial_duration: 500,
      data: { phase: "ready", ready_type: trialType, response_key: response_key },
    },
    {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '',
      choices: "NO_KEYS",
      trial_duration: interval_ms,
      data: { phase: "isi" },
    },
    {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<div class="circle set" 
    style="
      background-color:green;
      position:absolute;
      ${trialType === 'left' ? 'left:30%;' : 'right:30%;'}
      top:160px;
    ">
  </div>`,
        choices: "NO_KEYS",
      trial_duration: 500,
      data: { phase: "set_on_1" }
    },
    // {
    //   type: jsPsychHtmlKeyboardResponse,
    //   stimulus: '',
    //   choices: "NO_KEYS",
    //   trial_duration: setDuration,
    //   data: {
    //     phase: "set_gap",
    //     set_duration: setDuration
    //   }
    // },
    {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<div class="circle set" 
    style="
      background-color:green;
      position:absolute;
      ${trialType === 'left' ? 'left:30%;' : 'right:30%;'}
      top:160px;
    ">
  </div>`,
        choices: "NO_KEYS",
      trial_duration: 0,
      data: { phase: "set_on_2" }
    },
    {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '',
      choices: ['a','k'],
      data: {
        phase: "go",
        target_interval: interval_ms,
        set_duration: setDuration,
        response_key: response_key,
        ready_type: trialType
      },
      on_finish: function(data) {
        data.reproduced_interval = data.rt;
        data.reproduction_error = data.rt - data.target_interval;
        data.correct_key = data.response === data.response_key;
      },
    },
    {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `<div class="circle" 
    style="
      background-color:red;
      position:absolute;
      ${trialType === 'left' ? 'left:30%;' : 'right:30%;'}
      top:160px;
    ">
  </div>`,

      choices: "NO_KEYS",
      trial_duration: 500,
      data: { phase: "feedback_circle" },
    }
  ];

  if (1 < 2) {
    trialTimeline.push(
     
      {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function() {
          const lastGo = jsPsych.data.get().filter({ phase: 'go' }).last(1).values()[0];
          const current = jsPsych.data.get().filter({ phase: "go" }).count() ;
          const target = lastGo.target_interval;
          const reproduced = lastGo.reproduced_interval;
          const error = lastGo.reproduction_error;
          const key_result = lastGo.correct_key
          // Clamp error to range [-500, +500] for display
    const clampedError = Math.max(-500, Math.min(500, error));
    const percent = (clampedError + 500) / 1000 * 100;

    return `
      <div style="text-align:center;">
        <p style="font-size: 16px; text-align: center;">Trial ${current} of ${num_trials}</p>
        <p><strong>Error:</strong> ${error > 0 ? '+' : ''}${Math.round(error)} ms</p>

        <div style="position: relative; width: 80%; height: 40px; margin: 40px auto;">
          <div style="height: 8px; background: linear-gradient(to right, #3498db, #ccc, #e74c3c); border-radius: 4px;"></div>
          <div style="position: absolute; left: ${percent}%; top: -6px; transform: translateX(-50%);">
            <div style="width: 14px; height: 14px; background: black; border-radius: 50%; border: 2px solid white;"></div>
          </div>
          <div style="position: absolute; left: 0%; top: 20px; font-size: 12px;">â€“500 ms</div>
          <div style="position: absolute; left: 50%; top: 20px; font-size: 12px; transform: translateX(-50%);">0</div>
          <div style="position: absolute; right: 0%; top: 20px; font-size: 12px;">+500 ms</div>
        </div>
        <p>Key: <strong>${key_result}</strong></p>
        <p>Press any key to continue.</p>
      </div>
    `;
        
        },
        data: { phase: "feedback_text" },
        choices:['NO_KEYS'],
        trial_duration:500,
      },
      {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '<p style="font-size: 48px;">+</p>',
        choices: "NO_KEYS",
        trial_duration: 1000,
        data: { phase: "iti" },
      }
    );
  } else {
    trialTimeline.push({
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<p style="font-size: 48px;">+</p>',
      choices: "NO_KEYS",
      trial_duration: 1000,
      data: { phase: "iti" },
    });
  }

  return trialTimeline;
}



  const n = 5;
  
  const intervals = Array.from({ length: n }, (_, i) =>
    Math.round((lower_bound + (i * (upper_bound - lower_bound)) / (n - 1)) / 10) * 10
  );

  
  for (let i = 0; i < num_trials; i++) {
    const interval = jsPsych.randomization.sampleWithReplacement(intervals, 1)[0];
    timeline.push(...make_ready_set_go_trial(interval, i));
  }

  // Final feedback screen with scatter plot
  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div style="text-align:center;">
        <h2>Performance Summary</h2>
        <div id="plot"></div>
        <p>Each dot shows your reported interval vs actual interval per trial.</p>
        <p>Press any key to continue.</p>
      </div>
    `,
    choices: "ALL_KEYS",
    on_load: function() {
      const go_trials = jsPsych.data.get().filter({ phase: "go" }).values();
const set_durations = jsPsych.data.get().filter({ phase: "set_gap" }).values().map(t => t.set_duration);


// Group trials by set duration
const uniqueDurations = [...new Set(set_durations)].sort((a, b) => a - b);

const traces = uniqueDurations.map(dur => {
  const indices = set_durations
    .map((d, i) => d === dur ? i : -1)
    .filter(i => i !== -1);

  return {
    x: indices.map(i => go_trials[i].target_interval),
    y: indices.map(i => go_trials[i].reproduced_interval),
    mode: "markers",
    type: "scatter",
    name: `${dur} ms`,
    marker: {
      size: 10
    }
  };
});


const layout = {
  title: 'Reported vs Actual Interval (Colored by Set Duration)',
  xaxis: { title: "Actual Interval (ms)" },
  yaxis: { title: "Reported Interval (ms)" },
  margin: { t: 50, b: 50 },
  hovermode: "closest",
};

Plotly.newPlot("plot", traces, layout, { responsive: true });



    },
  });

  // Data saving trial
  timeline.push({
    type: jsPsychHtmlButtonResponse,
    stimulus: '<p>Click below to download your data as a CSV file.</p>',
    choices: ['Download CSV'],
    on_finish: function() {
  const csv = jsPsych.data.get().csv();

  // Get date in YYYYMMDD format
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const dateStr = `${year}${month}${day}`; // e.g., 20250716

  // Random 6-digit ID
  const randID = Math.floor(Math.random() * 1e6).toString().padStart(6, '0');

  const filename = `readysetgo_${dateStr}_${randID}.csv`;

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}


  });

  jsPsych.run(timeline);
</script>
</html>
